## Divide and Conquer

CLRS 4.1 - 4.7

## 递归场景总结

* **阶乘计算 (Factorial)**

  * **用法:** 计算一个非负整数n的阶乘（`n! = n * (n-1) * ... * 1`）。递归定义为 `factorial(n) = n * factorial(n-1)`，基本情况是 `factorial(0) = 1`。
* **斐波那契数列 (Fibonacci Sequence)**

  * **用法:** 生成一个数列，其中每个数是前两个数的和。递归定义为 `fib(n) = fib(n-1) + fib(n-2)`，基本情况是 `fib(0) = 0` 和 `fib(1) = 1`。
* **二分搜索 (Binary Search)**

  * **用法:** 在一个**已排序**的数组中快速查找目标值。算法每次将查找范围缩小一半，通过递归地在左半部分或右半部分进行搜索。
* **归并排序 (Merge Sort)**

  * **用法:** 一种高效、稳定的排序算法。它递归地将数组分成两半（或像图片中提到的三部分）并分别排序，然后将排序好的子数组合并起来。
* **快速排序 (Quick Sort)**

  * **用法:** 另一种非常高效的排序算法。它选择一个“基准”元素，将数组分区为小于和大于基准值的两个子数组，然后递归地对这两个子数组进行排序。
* **树的遍历 (Tree Traversal)**

  * **用法:** 以特定顺序访问树（如二叉树）的所有节点。
  * 这些遍历操作的定义本身就是递归的。
* **深度优先搜索 (Depth-First Search, DFS)**

  * **用法:** 在图或树中进行遍历或搜索。它从一个起点开始，沿着一条路径尽可能深地探索，直到无法继续，然后回溯到上一个节点，探索其他路径。
* **汉诺塔问题 (Tower of Hanoi)**

  * **用法:** 解决一个经典的益智游戏。将n个盘子从一个柱子移动到另一个柱子，其最优解法是天然的递归结构。
* **整数乘法 (Integer Multiplication)**

  * **用法:** 计算两个非常大的整数的乘积。像**卡拉楚巴算法 (Karatsuba Algorithm)**这样的方法通过将数字分解，递归地进行更少次数的乘法运算来提高效率。
* **矩阵乘法 (Matrix Multiplication)**

  * **用法:** 计算两个矩阵的乘积。
    * **常规递归:** 将矩阵分解为四个子矩阵，然后进行8次递归的子矩阵乘法。
* **施特拉森算法 (Strassen's Algorithm):** 上述 矩阵乘法的优化版本，是一种优化的分治算法，通过巧妙的代数运算，将递归乘法次数从8次减少到7次，从而在处理大矩阵时更快。
* **回溯算法 (Backtracking)**

  * **用法:** 在一个大的搜索空间中寻找问题的所有（或部分）解。当发现当前路径无法得到有效解时，算法会“回溯”到上一步，尝试其他选择。
  * **示例:** N皇后问题、解数独、生成所有排列组合。
* **分形绘制 (Fractal Drawing)**

  * **用法:** 生成具有自相似特性的复杂几何图形，如科赫雪花、谢尔宾斯基三角形等。图形的每个部分都是整体的缩小版，非常适合用递归来绘制。
* **文件系统遍历 (File System Traversal)**

  * **用法:** 遍历一个目录及其所有子目录中的文件和文件夹。一个函数处理当前目录，然后对其中的每个子目录递归地调用自身。
* **语法分析 (Parsing)**

  * **用法:** 在编译器或解释器中，分析代码的语法结构。编程语言的语法规则（如表达式、语句）通常是递归定义的，因此使用递归下降解析器来处理非常自然。
* **分治算法 (Divide and Conquer)**

  * **用法:** 一种重要的算法设计范式，递归是其核心实现方式。
  * **示例:** 寻找最大子数组问题、最近点对问题等。这些问题都可以通过递归地将问题分解，解决子问题，然后合并结果来高效求解。

.
